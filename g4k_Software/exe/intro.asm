; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\Users\polyr\Development\cpp\4k\g4k_Software\src\intro.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?intro_compute@@YGXPAIH@Z			; intro_compute
PUBLIC	__real@3a800000
PUBLIC	__real@3ae38e39
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@437f0000
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__ReleaseSemaphore@12:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__CreateThread@24:PROC
EXTRN	__imp__WaitForMultipleObjects@16:PROC
EXTRN	__imp__CreateSemaphoreA@16:PROC
EXTRN	?image_init@@YGXXZ:PROC				; image_init
EXTRN	?image_compute_fragment@@YGXPAMMM@Z:PROC	; image_compute_fragment
EXTRN	?f2i@@YGHM@Z:PROC				; f2i
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?fbuffer@@3PAMA DD 01b0000H DUP (?)			; fbuffer
_BSS	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3ae38e39
CONST	SEGMENT
__real@3ae38e39 DD 03ae38e39r			; 0.00173611
CONST	ENDS
;	COMDAT __real@3a800000
CONST	SEGMENT
__real@3a800000 DD 03a800000r			; 0.000976563
CONST	ENDS
; Function compile flags: /Ogspy
; File c:\users\polyr\development\cpp\4k\g4k_software\src\intro.cpp
;	COMDAT ?intro_compute@@YGXPAIH@Z
_TEXT	SEGMENT
tv430 = -1612						; size = 4
_i$1$ = -1612						; size = 4
tv432 = -1608						; size = 4
_barrier$1$ = -1604					; size = 4
_tileID$ = -1600					; size = 4
_thid$1 = -1540						; size = 4
_th$ = -1536						; size = 512
_idata$ = -1024						; size = 1024
_ibuffer$ = 8						; size = 4
_numCpus$ = 12						; size = 4
?intro_compute@@YGXPAIH@Z PROC				; intro_compute, COMDAT

; 48   : {

	push	ebp
	mov	ebp, esp
	and	esp, -32				; ffffffe0H
	sub	esp, 1624				; 00000658H
	push	esi

; 49   :     //--------------------------
; 50   :     ThreadData idata[128];
; 51   :     HANDLE     th[128];
; 52   :     HANDLE     barrier;
; 53   : 
; 54   : 	__declspec(align(32)) long tileID = 0;

	xor	esi, esi
	push	edi
	mov	DWORD PTR _tileID$[esp+1632], esi

; 55   : 
; 56   :  	image_init();

	call	?image_init@@YGXXZ			; image_init

; 57   : 
; 58   :     //--------------------------
; 59   : 
; 60   :     if( numCpus>128 ) numCpus=128;

	mov	edi, DWORD PTR _numCpus$[ebp]
	mov	eax, 128				; 00000080H
	cmp	edi, eax
	jle	SHORT $LN11@intro_comp
	mov	edi, eax
$LN11@intro_comp:

; 61   : 
; 62   : 	barrier = CreateSemaphore( 0, numCpus, numCpus, 0 );

	push	esi
	push	edi
	push	edi
	push	esi
	call	DWORD PTR __imp__CreateSemaphoreA@16

; 63   : 
; 64   : 	for( int i=0; i<numCpus; i++ )

	mov	DWORD PTR _i$1$[esp+1632], esi
	mov	ecx, eax
	mov	DWORD PTR _barrier$1$[esp+1632], ecx
	test	edi, edi
	jle	SHORT $LN3@intro_comp

; 61   : 
; 62   : 	barrier = CreateSemaphore( 0, numCpus, numCpus, 0 );

	lea	eax, DWORD PTR _idata$[esp+1632]
	mov	DWORD PTR tv432[esp+1632], eax
$LL4@intro_comp:

; 65   :     {
; 66   : 	    unsigned long thid;
; 67   :         idata[i].mutex = barrier;

	mov	DWORD PTR [eax], ecx

; 68   : 		idata[i].tileID = &tileID;

	lea	ecx, DWORD PTR _tileID$[esp+1632]
	mov	DWORD PTR [eax+4], ecx

; 69   :         th[i] = CreateThread( 0, 0, doWord, idata+i, 0, &thid );

	lea	ecx, DWORD PTR _thid$1[esp+1632]
	push	ecx
	push	esi
	push	eax
	push	OFFSET ?doWord@@YGKPAX@Z		; doWord
	push	esi
	push	esi
	call	DWORD PTR __imp__CreateThread@24
	mov	ecx, DWORD PTR _i$1$[esp+1632]
	mov	DWORD PTR _th$[esp+ecx*4+1632], eax
	inc	ecx
	mov	eax, DWORD PTR tv432[esp+1632]
	add	eax, 8
	mov	DWORD PTR _i$1$[esp+1632], ecx
	cmp	ecx, edi
	mov	DWORD PTR tv432[esp+1632], eax
	mov	ecx, DWORD PTR _barrier$1$[esp+1632]
	jl	SHORT $LL4@intro_comp
$LN3@intro_comp:

; 70   :     }
; 71   : 
; 72   :     // synch point
; 73   :     WaitForMultipleObjects(numCpus, th, true, INFINITE);

	push	-1
	push	1
	lea	eax, DWORD PTR _th$[esp+1640]
	push	eax
	push	edi
	call	DWORD PTR __imp__WaitForMultipleObjects@16

; 74   :     // free resources (yes!)
; 75   :     for( int i=0; i<numCpus; i++ ) CloseHandle(th[i]);

	test	edi, edi
	jle	SHORT $LN6@intro_comp
$LL7@intro_comp:
	push	DWORD PTR _th$[esp+esi*4+1632]
	call	DWORD PTR __imp__CloseHandle@4
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL7@intro_comp
$LN6@intro_comp:

; 76   :     CloseHandle(barrier);

	push	DWORD PTR _barrier$1$[esp+1632]
	call	DWORD PTR __imp__CloseHandle@4
	fld	DWORD PTR __real@437f0000
	mov	esi, OFFSET ?fbuffer@@3PAMA+4
	mov	DWORD PTR tv430[esp+1632], esi
$LN10@intro_comp:

; 77   : 
; 78   :     //--------------------------
; 79   : 	// float 2 int
; 80   :     //--------------------------
; 81   : 	for( int i=0; i<(IXRES*IYRES); i++ )
; 82   : 	{
; 83   : 		const int ir = f2i( fbuffer[3*i+0]*255.0f );

	fmul	DWORD PTR [esi-4]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?f2i@@YGHM@Z				; f2i

; 84   :         const int ig = f2i( fbuffer[3*i+1]*255.0f );

	fld	DWORD PTR [esi]
	mov	edi, eax
	fmul	DWORD PTR __real@437f0000
	push	ecx
	fstp	DWORD PTR [esp]
	call	?f2i@@YGHM@Z				; f2i
	mov	esi, eax

; 85   :         const int ib = f2i( fbuffer[3*i+2]*255.0f );

	mov	eax, DWORD PTR tv430[esp+1632]
	push	ecx
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR __real@437f0000
	fstp	DWORD PTR [esp]
	call	?f2i@@YGHM@Z				; f2i

; 86   : 		ibuffer[i] = 0xff000000 | (ir<<16) | (ig<<8) | ib;

	mov	ecx, DWORD PTR _ibuffer$[ebp]
	or	edi, -256				; ffffff00H
	fld	DWORD PTR __real@437f0000
	shl	edi, 8
	or	edi, esi
	mov	esi, DWORD PTR tv430[esp+1632]
	shl	edi, 8
	add	esi, 12					; 0000000cH
	or	eax, edi
	mov	DWORD PTR tv430[esp+1632], esi
	mov	DWORD PTR [ecx], eax
	add	ecx, 4
	mov	DWORD PTR _ibuffer$[ebp], ecx
	cmp	esi, OFFSET ?fbuffer@@3PAMA+7077892
	jl	SHORT $LN10@intro_comp

; 87   : 	}
; 88   : }

	pop	edi
	fstp	ST(0)
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?intro_compute@@YGXPAIH@Z ENDP				; intro_compute
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\polyr\development\cpp\4k\g4k_software\src\intro.cpp
;	COMDAT ?doWord@@YGKPAX@Z
_TEXT	SEGMENT
_j$1 = -12						; size = 4
tv300 = -8						; size = 4
_i$2 = -8						; size = 4
_ib$1$ = -4						; size = 4
_vdata$ = 8						; size = 4
?doWord@@YGKPAX@Z PROC					; doWord, COMDAT

; 23   : {

	sub	esp, 12					; 0000000cH
	push	edi

; 24   :     ThreadData *data = (ThreadData*)vdata;
; 25   : 
; 26   :     WaitForSingleObject( (HANDLE*)data->mutex, 0 );

	mov	edi, DWORD PTR _vdata$[esp+12]
	push	0
	push	DWORD PTR [edi]
	call	DWORD PTR __imp__WaitForSingleObject@8

; 27   : 
; 28   : 	const int numtiles = IXRES/TILESIZE;
; 29   : 	for(;;)
; 30   : 	{
; 31   : 		const int tile = InterlockedIncrement( data->tileID ) - 1;

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	inc	ecx
	lock	 xadd	 DWORD PTR [eax], ecx
	inc	ecx
	dec	ecx

; 32   : 		if( tile >= numtiles ) break;

	cmp	ecx, 128				; 00000080H
	jge	$LN17@doWord
	fld	DWORD PTR __real@40000000
	fld	DWORD PTR __real@3a800000
	fld1
	fld	DWORD PTR __real@3ae38e39
	push	ebx
	push	ebp
	push	esi
$LN2@doWord:

; 33   : 		const int ia = tile*TILESIZE;

	mov	esi, ecx
	shl	esi, 3

; 34   : 		const int ib = ia + TILESIZE;
; 35   : 		for( int i=ia; i<ib; i++ )

	mov	DWORD PTR _i$2[esp+28], esi
	lea	ebp, DWORD PTR [esi+8]
	mov	DWORD PTR _ib$1$[esp+28], ebp
	cmp	esi, ebp
	jge	$LN6@doWord

; 33   : 		const int ia = tile*TILESIZE;

	imul	ebx, esi, 12
	add	ebx, OFFSET ?fbuffer@@3PAMA
	jmp	SHORT $LN7@doWord
$LN39@doWord:
	fxch	ST(2)
	fxch	ST(3)
	fxch	ST(1)
	fxch	ST(2)
$LN7@doWord:
	fild	DWORD PTR _i$2[esp+28]

; 36   : 		for( int j=0; j<IYRES; j++ )

	xor	edi, edi
	mov	ebp, ebx
	mov	DWORD PTR _j$1[esp+28], edi
	fmulp	ST(4), ST(0)
	fxch	ST(3)
	fmulp	ST(2), ST(0)
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fst	DWORD PTR tv300[esp+28]
	jmp	SHORT $LN10@doWord
$LN34@doWord:
	fxch	ST(2)
	fxch	ST(1)
$LN10@doWord:

; 37   : 		{
; 38   : 			image_compute_fragment( fbuffer+3*(IXRES*j+i), -1.0f+2.0f*(float)i/(float)IXRES, 1.0f-2.0f*(float)j/(float)IYRES );

	fild	DWORD PTR _j$1[esp+28]
	push	ecx
	push	ecx
	fld	ST(0)
	fmul	ST(0), ST(4)
	fxch	ST(1)
	fmulp	ST(4), ST(0)
	faddp	ST(3), ST(0)
	fxch	ST(1)
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR [esp+4]
	fstp	DWORD PTR [esp]
	push	ebp
	call	?image_compute_fragment@@YGXPAMMM@Z	; image_compute_fragment
	fld1
	inc	edi
	fld	DWORD PTR tv300[esp+28]
	add	ebp, 12288				; 00003000H
	fld	DWORD PTR __real@3ae38e39
	mov	DWORD PTR _j$1[esp+28], edi
	cmp	edi, 576				; 00000240H
	jl	SHORT $LN34@doWord

; 34   : 		const int ib = ia + TILESIZE;
; 35   : 		for( int i=ia; i<ib; i++ )

	fstp	ST(2)
	inc	esi
	fstp	ST(0)
	mov	DWORD PTR _i$2[esp+28], esi
	fstp	ST(0)
	add	ebx, 12					; 0000000cH
	fld1
	fld	DWORD PTR __real@40000000
	fld	DWORD PTR __real@3a800000
	fld	DWORD PTR __real@3ae38e39
	cmp	esi, DWORD PTR _ib$1$[esp+28]
	jl	$LN39@doWord
	mov	edi, DWORD PTR _vdata$[esp+24]
	fstp	ST(2)
	fstp	ST(2)
	fstp	ST(1)
	fstp	ST(0)
	fld1
	fld	DWORD PTR __real@40000000
	fld	DWORD PTR __real@3a800000
	fld	DWORD PTR __real@3ae38e39
	fxch	ST(2)
	fxch	ST(3)
	fxch	ST(1)
	fxch	ST(2)
$LN6@doWord:

; 27   : 
; 28   : 	const int numtiles = IXRES/TILESIZE;
; 29   : 	for(;;)
; 30   : 	{
; 31   : 		const int tile = InterlockedIncrement( data->tileID ) - 1;

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	inc	ecx
	lock	 xadd	 DWORD PTR [eax], ecx
	inc	ecx
	dec	ecx

; 32   : 		if( tile >= numtiles ) break;

	cmp	ecx, 128				; 00000080H
	jl	$LN2@doWord
	fstp	ST(3)
	fstp	ST(0)
	pop	esi
	fstp	ST(0)
	pop	ebp
	fstp	ST(0)
	pop	ebx
$LN17@doWord:

; 39   : 		}
; 40   : 	}
; 41   : 
; 42   :     ReleaseSemaphore( (HANDLE*)data->mutex, 1, NULL );

	push	0
	push	1
	push	DWORD PTR [edi]
	call	DWORD PTR __imp__ReleaseSemaphore@12

; 43   : 
; 44   :     return 1;

	xor	eax, eax
	inc	eax
	pop	edi

; 45   : }

	add	esp, 12					; 0000000cH
	ret	4
?doWord@@YGKPAX@Z ENDP					; doWord
_TEXT	ENDS
END
